<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <script>
        /* 最长递增子序列问题[1,5,2,4,3]        代码思路-基于递归
        1-子串问题，递归解决，直接定义func返回子元素的result
        2-递归参数，子元素、子串序列，   递归条件：后节点>当前节点,   子递归返回结果: 最大长度
        3-递归出口：遍历到最后一个元素时，则return 1（假设只有一个元素的话就是1）
        4-调用递归：遍历元素调用递归，返回数组，表示每个元素起始的最长递增子序列长度
            */

        let stack = {}
        function L(str, i) {
            if (Object.keys(stack).includes(i)) {
                return stack.i
            }

            if (i === str.length - 1) {
                return 1
            }

            let max_len = 1
            for (let j = i + 1; j < str.length - 1; j++) {
                if (str[j] > str[i]) {
                    max_len = Math.max(max_len, L(str, j) + 1)    // i 的result

                }
            }
            stack[i] = max_len                                // 存入栈中
            return max_len
        }

        function main(str) {
            let max_map = []
            for (let i = 0; i < str.length; i++) {
                max_map.push(L(str, i))
            }
            max_map.s
            console.log((max_map));
            return Math.max(max_map)
        }
        main([1, 5, 2, 4, 3])

        /* 非递归、迭代实现，
        1、dp[i]定义，dp表示以num[i]为结尾的递增子序列中最长递增子序列的长度，i表示num[i]，也就是说dp[i]要求其所有递增子序列都是以num[i]结尾，即num[i]最大
        2、递推，最终版，通过举例子发现，
                dp[i]的值，看num[i-1]是否为0-i-1递增子序列中的结尾，如果是则dp[i]=dp[i-1]+1 ，否则找到max(dp[j])+1 j<i-1, num[j]< num[i],没有则=0
                所以，其实要遍历0-i-1，直到到找一个num[j]<num[i] 则dp[i]=dp[j]+1,如果没有则dp[i]=1

                更正dp[n] = dp[n-1]+1 if num[n]>num[n-1] 或者 max(dp[j])+1 0<=j<=n-1 (num[j]<num[n])         ×
                dp[n]= dp[n-1]+1 if num[n]>num[n-1] else max( dp[j] ) (num[j]<num[n])  0<=j<=n-1            ×
                ......
                dp[1]=dp[0]+1 if num[1]>num[0] else dp[0]
                dp[0]=1
        3、初始化，i=1
        4、遍历1-n
        5、举例子 arr=[4,10,4,3,8,9]  
                则 dp=[1,2, 1,0,2,3],严格把控定义，dp[i]表示以arr[i]为结尾的递增子序列的最大长度,也就是说arr[i]必须最大
        */
        function f3(nums) {
            let dp = [1]
            let max = 0
            if (nums.length === 1) {
                return dp[0]
            }
            /* 最终版 */

            for (let i = 1; i < nums.length; i++) {
                let subMax = []
                for (let j = 0; j < i; j++) {
                    if (nums[j] < nums[i]) {
                        subMax.push(dp[j])
                    }
                }
                let subIndex = subMax.length !== 0 ? Math.max.apply(null, subMax) : 0
                dp[i] = subIndex + 1
            }

            /*             
            for (let i = 1; i < array.length; i++) {
                if (array[i] > array[i - 1]) {
                    dp[i] = dp[i - 1] + 1
                } else {
                    // 遍历所有小于array[i]的元素，找到其中dp最大的+1
                    let subDp = []
                    array.slice(0, i).forEach((element, index) => {
                        if (element < array[i])
                            subDp.push(dp[index])
                    });
                    let subMax = subDp.length !== 0 ? Math.max.apply(null, subDp) : 0
                    dp[i] = subMax + 1
                }
            } */
            /*             
            for (let i = 1; i < array.length; i++) {       有误区，注意dp定义,
                if (array[i] > array[i - 1]) {
                    dp[i] = dp[i - 1] + 1
                } else {
                    dp[i] = dp[i - 1]}
                if (dp[i] > max) {
                    max = dp[i]}
            } */

            /*    还是有误区，内循环对比的方式不对     
            for (let i = 1; i < array.length; i++) {
                if (array[i] > array[i - 1]) {
                    dp[i] = dp[i - 1] + 1
                } else {
                    for (let j = i - 1; j >= 0; j--) {
                        if (array[j] < array[i]) {
                            dp[i] = dp[j] + 1
                        }
                        else {
                            let ar = dp.slice(0, i)
                            dp[i] = Math.max(...ar)
                        }
                    }
                }
            } */
            max = Math.max(...dp)
            return max
        }
        console.time('动态规划')
        // console.log(f3([4, 10, 4, 3, 8, 9]));
        console.log(f3([1, 3, 6, 7, 9, 4, 10, 5, 6]));
        console.timeEnd('动态规划')
    </script>
</body>

</html>