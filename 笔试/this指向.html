<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <script>

        // 定义3个对象
        function Car(type, fuelType) {
            this.type = type
            this.fuelType = fuelType
        }

        function setBrand(brand) {
            Car.call(this, type = 'convertible', fuelType = 'pretrol')
            this.brand = brand
            console.log(`Car details = `, this);
        }
        function definePrice(price) {
            Car.call(this, "convertible", "diesel");
            this.price = price;
            console.log(`Car details = `, this);
        }

        const newBrand = new setBrand('Brand1');
        const newCarPrice = new definePrice(100000);

        // 不传thisobj
        const newEntity = (obj) => console.log(obj);
        function mountEntity() {
            this.entity = newEntity;
            console.log(`Entity ${this.entity} is mounted on ${this}`);
        }
        mountEntity.call(); //输出： Entity (obj) => console.log(obj) is mounted on [object Window]


        // bind更加灵活
        function Car(type, fuelType) {
            this.type = type;
            this.fuelType = fuelType;
        }

        function setBrand(brand) {
            Car.apply(this, ["convertible", "petrol"]); //使用数组字面量的语法
            this.brand = brand;
            console.log(`Car details = `, this);
        }

        function definePrice(price) {
            Car.apply(this, new Array("convertible", "diesel")); //使用数组构建函数的语法
            this.price = price;
            console.log(`Car details = `, this);
        }

        const newBrand1 = new setBrand('Brand1');
        const newCarPrice1 = new definePrice(100000);

        // apply使用argument获取参数
        function addUp() {
            //使用参数捕获任意数量的输入
            const args = Array.from(arguments);
            this.x = args.reduce((prev, curr) => prev + curr, 0);
            console.log("this = ", this);
            console.log("this.x = ", this.x);
        }

        function driverFunc() {
            const obj = {
                inps: [1, 2, 3, 4, 5, 6]
            }
            addUp.apply(obj, obj.inps);   // addUp的this指向obj，即 {inps:[1,2,3,4,5,6], x:21}
        }
        driverFunc(); //输出： this.x =  21

        // 经典例子
        var name = "lucy";
        var obj = {
            name: "martin",
            say: function () {
                console.log(this.name);
            }
        };
        obj.say();                           // martin，this 指向 obj 对象
        setTimeout(obj.say, 0);              // lucy，this 指向 window 对象
        setTimeout(obj.say(), 0);            // martin，,立即执行函数，this指向调用者obj，并且返回值是undefined，所以settimeout不会有动作
        // setTimeout(obj.say.call(obj), 0); // martin，this指向obj对象
        /* 
        obj.say.call(obj) 是一个立即执行的表达式，call() 会立即调用 say 方法，并将 this 绑定为 obj，
        因此立即输出 martin。注意，这一行代码中 setTimeout 的参数并不是 obj.say 函数，
        而是 obj.say.call(obj) 的返回值（undefined），因此 setTimeout 并不会做任何事情，只是延时。 
        */
        // setTimeout(obj.say.bind(obj), 0); //martin，this指向obj对象
        /* 
        bind() 不会立即执行函数，而是返回一个新的函数，并将 this 永久绑定为传入的 obj。
        因此，传入 setTimeout 的是一个已经绑定了 this 的新函数。当这个函数在 setTimeout 中执行时，this 始终指向 obj，
        所以 this.name 输出 martin。 
        */




        // bind
        function fn(...args) {
            console.log(this, args);
        }
        let obj1 = {
            myname: "张三"
        }

        // const bindFn = fn.bind(obj1); // this 也会变成传入的obj ，bind不是立即执行需要执行一次
        // bindFn(1, 2)  // this指向obj        {myname: "张三"}   [1,2]
        // fn(1, 2)      // this指向window     windows    [1,2]
    </script>
</body>

</html>